<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>SVG Editor</title>
    <link rel="icon" href="https://raw.githubusercontent.com/KamilGajos/home/38e51c3f57248d6b9d08a4df1f6a1926536ab721/icon.svg" type="image/svg+xml">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.cdnfonts.com/css/rostex" rel="stylesheet">


    <style>
        /* ------------------ DESIGN TOKENS ------------------ */
        :root {
            --color-bg-surface1: #F1F1F1;
            --color-bg-surface2: #FDFDFD;
            --color-bg-surface3: #E2E2E2;
            --color-bg-dark1: #282828;
            --color-bg-dark2: #141414;
            --color-bg-primary: #2D68FF;
            --color-bg-highlight: rgba(226, 226, 226, .3);
            --color-bg-subtle: rgba(226, 226, 226, .5);
            --color-bg-subtle2: #f6f6f6;
            --color-bg-freebie: #E2E2E2;

            --color-text-primary: #1B1B1B;
            --color-text-primary-hover: rgba(27, 27, 27, .7);
            --color-text-secondary: #727272;
            --color-text-tertiary: #A8A8A8;
            --color-text-light: #FDFDFD;
            --color-text-blue: #2D68FF;

            --color-stroke1: #E2E2E2;
            --color-stroke2: #E2E2E2;
            --color-stroke-subtle: rgba(168, 168, 168, .1);
            --color-stroke-subtle2: #E7E7E7;
            --color-stroke-focus: #2D68FF;
            --color-stroke-highlight: rgba(168, 168, 168, .5);
            --color-stroke-super-light: rgba(226, 226, 226, .25);

            --color-primary1: #2D68FF;
            --color-primary2: #00A656;
            --color-primary3: #FF381C;
            --color-accent: #F52495;

            --color-card-stroke: transparent;
            --color-card-like-bg: #FDFDFD;
            --color-today-stroke: #FCEBF4;
            --color-today-bg: #FDF5FA;

            --color-report-bg: #F1F1F1;
            --color-bg-plugin: rgba(253, 253, 253, .3);
        }

        /* ------------------ BASE / GLOBAL ------------------ */

        body {
            background: var(--color-bg-surface1);
            color: var(--color-text-primary);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
        }

        h1 {
            font-family: 'Rostex', sans-serif;
        }


        svg {
            touch-action: none;
            user-select: none;
        }

        /* Handles on the SVG shape */
        .handle {
            cursor: pointer;
            transition: transform 0.1s;
            transform-box: fill-box;
            transform-origin: center;
        }

        .handle:hover {
            transform: scale(1.2);
        }

        .handle.selected {
            fill: #dec122 !important;
            stroke: #2D68FF !important;
            stroke-width: 2.5 !important;
        }

        .handle.dragging {
            transform: none !important;
            transition: none !important;
        }

        /* ------------------ LIGHT-THEME REMAP FOR THIS FILE ------------------ */

        /* Backgrounds */
        .bg-slate-950 {
            background-color: var(--color-bg-surface1) !important;
        }

        .bg-slate-950\/80 {
            background-color: rgba(253, 253, 253, 0.96) !important;
        }

        .bg-slate-900 {
            background-color: var(--color-bg-surface2) !important;
        }

        .bg-slate-900\/60 {
            background-color: rgba(253, 253, 253, 0.9) !important;
        }

        /* Borders */
        .border-slate-800,
        .border-slate-700 {
            border-color: var(--color-stroke-subtle2) !important;
        }

        .border-t.border-slate-800 {
            border-top-color: var(--color-stroke-subtle2) !important;
        }

        .border-l.border-slate-800 {
            border-left-color: var(--color-stroke-subtle2) !important;
        }

        /* Text colors */
        .text-slate-100,
        .text-slate-900 {
            color: var(--color-text-primary) !important;
        }

        .text-slate-300,
        .text-slate-400 {
            color: var(--color-text-secondary) !important;
        }

        .text-slate-500 {
            color: var(--color-text-tertiary) !important;
        }

        /* Small status pill */
        .inline-flex.rounded-full.border-slate-700 {
            background: var(--color-bg-subtle2);
            border-color: var(--color-stroke-subtle2) !important;
            color: var(--color-text-secondary) !important;
        }

        /* Inputs / selects / number fields */
        .border-slate-800.bg-slate-900 {
            background-color: var(--color-bg-surface2) !important;
            border-color: var(--color-stroke-subtle2) !important;
            color: var(--color-text-primary) !important;
        }

        .text-slate-300 {
            color: var(--color-text-secondary) !important;
        }

        .focus\:ring-slate-500:focus {
            --tw-ring-color: var(--color-stroke-focus) !important;
        }

        /* Sliders, checkboxes accent color */
        .accent-slate-100 {
            accent-color: var(--color-primary1) !important;
        }


        input[type="range"].accent-slate-100 {
            accent-color: var(--color-primary1) !important;
        }

        /* Checkboxes that were dark */
        .bg-slate-900.rounded {
            background-color: var(--color-bg-surface2) !important;
            border-color: var(--color-stroke-subtle2) !important;
        }

        /* File upload button */
        .file\:bg-slate-100::file-selector-button {
            background-color: var(--color-bg-subtle2) !important;
            color: var(--color-text-primary) !important;
        }

        .file\:text-slate-900::file-selector-button {
            color: var(--color-text-primary) !important;
        }

        .hover\:file\:bg-slate-200:hover::file-selector-button {
            background-color: var(--color-bg-subtle) !important;
        }

        /* Right sidebar buttons */
        .bg-slate-900.border-slate-700.hover\:bg-slate-800 {
            background-color: var(--color-bg-surface2) !important;
            border-color: var(--color-stroke-subtle2) !important;
        }

        .bg-slate-900.border-slate-700.hover\:bg-slate-800:hover {
            background-color: var(--color-bg-subtle2) !important;
        }

        /* Primary / contrast buttons */
        .bg-slate-100.text-slate-900 {
            background-color: var(--color-bg-primary) !important;
            color: var(--color-text-light) !important;
        }

        .bg-slate-100.text-slate-900:hover {
            background-color: var(--color-primary1) !important;
            filter: brightness(0.95);
        }

        button[data-tab-button].border-slate-100 {
            border-color: var(--color-bg-primary) !important;
            color: var(--color-bg-primary) !important;
        }

        /* Active shape selector button */
        .shape-select-btn-active {
            background-color: var(--color-primary1) !important;
            color: var(--color-text-light) !important;
            border-color: var(--color-primary1) !important;
        }

        /* Selected row (always solid blue) */
        .point-row-selected {
            background: var(--color-primary1) !important;
            color: var(--color-text-light) !important;
        }

        /* Hover row (only when NOT selected) */
        .point-row:not(.point-row-selected):hover {
            background: rgba(45, 104, 255, 0.25) !important;
            color: var(--color-text-light) !important;
        }

        /* Coordinates also turn white on hover/selected */
        .point-row-selected .point-row-coord,
        .point-row:not(.point-row-selected):hover .point-row-coord {
            color: var(--color-text-light) !important;
        }

        /* SVG title layout */
        .svg-title {
            display: inline-flex;
            align-items: baseline;
            gap: 0.35rem;
            /* space between S, V, G blocks */
        }

        /* Each letter + its expanding word */
        .svg-chunk {
            display: inline-flex;
            align-items: baseline;
            cursor: default;
        }

        /* The base letter (S, V, G) */
        .svg-main {
            display: inline-block;
        }

        /* The part that expands: "calable", "ector", "raphics" */
        .svg-extra {
            display: inline-block;
            overflow: hidden;
            white-space: nowrap;

            max-width: 0;
            opacity: 0;
            margin-left: 0;

            transition:
                max-width 700ms ease,
                opacity 700ms ease,
                margin-left 700ms ease;
        }

        /* On hover: expand the extra text to the right */
        .svg-chunk:hover .svg-extra {
            max-width: 10ch;
            opacity: 1;
            margin-left: 0.15em;
        }

        .tab-btn {
            position: relative;
            border-bottom: none !important;
        }

        #toolbarTabIndicator {
            width: 0;
            left: 0;
        }
    </style>

</head>

<body class="bg-slate-950 text-slate-100">
    <div class="w-screen h-screen flex">
        <!-- Canvas 75% -->
        <div class="flex-[3] flex items-center justify-center p-4">
            <div class="w-full h-full rounded-3xl bg-slate-900/60 border border-slate-800 overflow-hidden flex items-center justify-center relative">

                <!-- Canvas loading overlay -->
                <div id="canvasLoadingOverlay" class="pointer-events-none absolute inset-0 flex items-center justify-center
                   bg-slate-950/40 opacity-0 transition-opacity duration-200 z-50">
                    <div class="rounded-2xl border border-slate-700 bg-slate-900/80 px-4 py-2
                        flex items-center gap-2 text-[11px] text-slate-200">
                        <div class="h-1.5 w-16 rounded-full bg-slate-800 overflow-hidden">
                            <div class="h-full w-1/2 bg-slate-300/90 animate-pulse"></div>
                        </div>
                        <span>Loading image…</span>
                    </div>
                </div>

                <!-- SVG Editor -->
                <svg id="editor" viewBox="0 0 1000 1000" class="w-full h-full max-w-full max-h-full">
                    <defs>
                        <!-- Checkerboard pattern -->
                        <pattern id="checker" x="0" y="0" width="40" height="40" patternUnits="userSpaceOnUse">
                            <rect x="0" y="0" width="40" height="40" fill="var(--color-bg-surface2)" />
                            <rect x="0" y="0" width="20" height="20" fill="var(--color-bg-surface2)" />
                            <rect x="20" y="20" width="20" height="20" fill="var(--color-bg-surface2)" />
                            <rect x="0" y="0" width="20" height="20" fill="var(--color-bg-surface3)" />
                            <rect x="20" y="20" width="20" height="20" fill="var(--color-bg-surface3)" />
                        </pattern>

                        <!-- Clip paths will be dynamically added here -->
                    </defs>

                    <!-- Background -->
                    <rect id="checkerBackground" x="0" y="0" width="1000" height="1000" fill="url(#checker)"></rect>

                    <g id="shapeLayers">
                        <!-- Shape layers (image + frame) will be dynamically added here -->
                    </g>

                    <!-- Point handles (for the active shape) -->
                    <g id="handles"></g>
                </svg>
            </div>
        </div>

    <!-- Toolbar 25% -->
<div class="flex-[1] min-w-0 border-l border-slate-800 bg-slate-950/80 p-4 flex flex-col gap-4 mt-4 mb-4 mr-4 rounded-3xl overflow-y-auto">
    <!-- Header -->
    <div class="flex items-center gap-2 mb-1">

        <!-- Icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <title>app-stack</title>
            <g fill="none">
                <path d="M1 8.34944C1 7.31285 1 6.79455 1.15365 6.33311C1.28957 5.92492 1.5117 5.55074 1.80496 5.23595C2.13648 4.8801 2.59149 4.63191 3.50151 4.13554L7.26767 2.08127C8.82638 1.23107 9.60573 0.805964 10.2428 0.883876C10.7987 0.951865 11.3007 1.24983 11.6265 1.70532C12 2.22728 12 3.11503 12 4.89053V12.6506C12 13.6872 12 14.2054 11.8463 14.6669C11.7104 15.0751 11.4883 15.4493 11.195 15.764C10.8635 16.1199 10.4085 16.3681 9.49849 16.8645L5.73233 18.9187C4.17362 19.7689 3.39427 20.194 2.75721 20.1161C2.20129 20.0481 1.69935 19.7502 1.37346 19.2947C1 18.7727 1 17.885 1 16.1095V8.34944Z" fill="url(#1752500502765-1629809_app-stack_existing_0_7rc9rg3ep)" data-glass="origin" mask="url(#1752500502765-1629809_app-stack_mask_r8fdhnnhy)"></path>
                <path d="M1 8.34944C1 7.31285 1 6.79455 1.15365 6.33311C1.28957 5.92492 1.5117 5.55074 1.80496 5.23595C2.13648 4.8801 2.59149 4.63191 3.50151 4.13554L7.26767 2.08127C8.82638 1.23107 9.60573 0.805964 10.2428 0.883876C10.7987 0.951865 11.3007 1.24983 11.6265 1.70532C12 2.22728 12 3.11503 12 4.89053V12.6506C12 13.6872 12 14.2054 11.8463 14.6669C11.7104 15.0751 11.4883 15.4493 11.195 15.764C10.8635 16.1199 10.4085 16.3681 9.49849 16.8645L5.73233 18.9187C4.17362 19.7689 3.39427 20.194 2.75721 20.1161C2.20129 20.0481 1.69935 19.7502 1.37346 19.2947C1 18.7727 1 17.885 1 16.1095V8.34944Z" fill="url(#1752500502765-1629809_app-stack_existing_0_7rc9rg3ep)" data-glass="clone" filter="url(#1752500502765-1629809_app-stack_filter_fsjf1us0i)" clip-path="url(#1752500502765-1629809_app-stack_clipPath_fd5fidq46)"></path>
                <path d="M6.5 9.84944C6.5 8.81285 6.5 8.29455 6.65365 7.83311C6.78957 7.42492 7.0117 7.05074 7.30496 6.73595C7.63648 6.3801 8.09149 6.13191 9.00151 5.63554L12.7677 3.58127C14.3264 2.73107 15.1057 2.30596 15.7428 2.38388C16.2987 2.45187 16.8007 2.74983 17.1265 3.20532C17.5 3.72728 17.5 4.61503 17.5 6.39053V14.1506C17.5 15.1872 17.5 15.7054 17.3463 16.1669C17.2104 16.5751 16.9883 16.9493 16.695 17.264C16.3635 17.6199 15.9085 17.8681 14.9985 18.3645L11.2323 20.4187C9.67362 21.2689 8.89427 21.694 8.25721 21.6161C7.70129 21.5481 7.19935 21.2502 6.87346 20.7947C6.5 20.2727 6.5 19.385 6.5 17.6095V9.84944Z" fill="url(#1752500502765-1629809_app-stack_existing_1_1zg495t0r)" data-glass="blur"></path>
                <path d="M15.7432 2.38348C16.2989 2.45155 16.8011 2.7495 17.127 3.20477C17.5004 3.72671 17.5 4.61505 17.5 6.39032V14.1501C17.5 15.1865 17.5002 15.7053 17.3467 16.1667L17.291 16.3181C17.1535 16.6672 16.9517 16.9881 16.6953 17.2634L16.5645 17.3932C16.3449 17.5931 16.0654 17.7693 15.6572 17.9997H14.1006L14.6396 17.7057C15.5951 17.1846 15.9176 16.9983 16.1465 16.7526C16.3663 16.5166 16.5329 16.2354 16.6348 15.9294C16.7407 15.6109 16.75 15.2382 16.75 14.1501V6.39032C16.75 5.48807 16.7488 4.86287 16.7061 4.39618C16.663 3.92695 16.5853 3.73729 16.5166 3.6413C16.3129 3.35677 15.9987 3.1701 15.6514 3.12762C15.5341 3.11341 15.3305 3.13621 14.8984 3.32294C14.4683 3.50884 13.919 3.80693 13.127 4.23895L9.36035 6.29364C8.40497 6.81476 8.08241 7.00114 7.85352 7.24677C7.63365 7.48278 7.46718 7.76398 7.36523 8.07001C7.25922 8.38856 7.25 8.7611 7.25 9.8493V17.6091C7.25 17.7997 7.25147 17.9782 7.25195 18.1452C6.96284 18.2619 6.70849 18.445 6.50488 18.6745C6.50072 18.36 6.5 18.0067 6.5 17.6091V9.8493C6.5 8.81291 6.49969 8.2941 6.65332 7.8327C6.77227 7.47559 6.95742 7.14418 7.19824 6.85614L7.30469 6.73602C7.55334 6.46917 7.87195 6.2624 8.39941 5.96649L9.00195 5.63544L12.7676 3.58075C14.3262 2.73061 15.1061 2.30559 15.7432 2.38348Z" fill="url(#1752500502765-1629809_app-stack_existing_2_nu478vkuo)"></path>
                <path d="M12 11.3494C12 10.3128 12 9.79455 12.1537 9.33311C12.2896 8.92492 12.5117 8.55074 12.805 8.23595C13.1365 7.8801 13.5915 7.63191 14.5015 7.13554L18.2677 5.08127C19.8264 4.23107 20.6057 3.80596 21.2428 3.88388C21.7987 3.95187 22.3007 4.24983 22.6265 4.70532C23 5.22728 23 6.11503 23 7.89053V15.6506C23 16.6872 23 17.2054 22.8463 17.6669C22.7104 18.0751 22.4883 18.4493 22.195 18.764C21.8635 19.1199 21.4085 19.3681 20.4985 19.8645L16.7323 21.9187C15.1736 22.7689 14.3943 23.194 13.7572 23.1161C13.2013 23.0481 12.6993 22.7502 12.3735 22.2947C12 21.7727 12 20.885 12 19.1095V11.3494Z" fill="url(#1752500502765-1629809_app-stack_existing_3_ufuzjtqyg)"></path>
                <defs>
                    <linearGradient id="1752500502765-1629809_app-stack_existing_0_7rc9rg3ep" x1="6.5" y1="-.5" x2="6.5" y2="21.5" gradientUnits="userSpaceOnUse">
                        <stop stop-color="#575757"></stop>
                        <stop offset="1" stop-color="#151515"></stop>
                    </linearGradient>
                    <linearGradient id="1752500502765-1629809_app-stack_existing_1_1zg495t0r" x1="12" y1="1" x2="12" y2="23" gradientUnits="userSpaceOnUse">
                        <stop stop-color="#E3E3E5" stop-opacity=".6"></stop>
                        <stop offset="1" stop-color="#BBBBC0" stop-opacity=".6"></stop>
                    </linearGradient>
                    <linearGradient id="1752500502765-1629809_app-stack_existing_2_nu478vkuo" x1="12" y1="2.375" x2="12" y2="17.5" gradientUnits="userSpaceOnUse">
                        <stop stop-color="#fff" stop-opacity="1"></stop>
                        <stop offset="1" stop-color="#fff" stop-opacity="0"></stop>
                    </linearGradient>
                    <linearGradient id="1752500502765-1629809_app-stack_existing_3_ufuzjtqyg" x1="17.5" y1="2.5" x2="17.5" y2="24.5" gradientUnits="userSpaceOnUse">
                        <stop stop-color="#575757"></stop>
                        <stop offset="1" stop-color="#151515"></stop>
                    </linearGradient>
                    <filter id="1752500502765-1629809_app-stack_filter_fsjf1us0i" x="-100%" y="-100%" width="400%" height="400%" filterUnits="objectBoundingBox" primitiveUnits="userSpaceOnUse">
                        <feGaussianBlur stdDeviation="2" x="0%" y="0%" width="100%" height="100%" in="SourceGraphic" edgeMode="none" result="blur"></feGaussianBlur>
                    </filter>
                    <clipPath id="1752500502765-1629809_app-stack_clipPath_fd5fidq46">
                        <path d="M6.5 9.84944C6.5 8.81285 6.5 8.29455 6.65365 7.83311C6.78957 7.42492 7.0117 7.05074 7.30496 6.73595C7.63648 6.3801 8.09149 6.13191 9.00151 5.63554L12.7677 3.58127C14.3264 2.73107 15.1057 2.30596 15.7428 2.38388C16.2987 2.45187 16.8007 2.74983 17.1265 3.20532C17.5 3.72728 17.5 4.61503 17.5 6.39053V14.1506C17.5 15.1872 17.5 15.7054 17.3463 16.1669C17.2104 16.5751 16.9883 16.9493 16.695 17.264C16.3635 17.6199 15.9085 17.8681 14.9985 18.3645L11.2323 20.4187C9.67362 21.2689 8.89427 21.694 8.25721 21.6161C7.70129 21.5481 7.19935 21.2502 6.87346 20.7947C6.5 20.2727 6.5 19.385 6.5 17.6095V9.84944Z" fill="url(#1752500502765-1629809_app-stack_existing_1_1zg495t0r)"></path>
                    </clipPath>
                    <mask id="1752500502765-1629809_app-stack_mask_r8fdhnnhy">
                        <rect width="100%" height="100%" fill="#FFF"></rect>
                        <path d="M6.5 9.84944C6.5 8.81285 6.5 8.29455 6.65365 7.83311C6.78957 7.42492 7.0117 7.05074 7.30496 6.73595C7.63648 6.3801 8.09149 6.13191 9.00151 5.63554L12.7677 3.58127C14.3264 2.73107 15.1057 2.30596 15.7428 2.38388C16.2987 2.45187 16.8007 2.74983 17.1265 3.20532C17.5 3.72728 17.5 4.61503 17.5 6.39053V14.1506C17.5 15.1872 17.5 15.7054 17.3463 16.1669C17.2104 16.5751 16.9883 16.9493 16.695 17.264C16.3635 17.6199 15.9085 17.8681 14.9985 18.3645L11.2323 20.4187C9.67362 21.2689 8.89427 21.694 8.25721 21.6161C7.70129 21.5481 7.19935 21.2502 6.87346 20.7947C6.5 20.2727 6.5 19.385 6.5 17.6095V9.84944Z" fill="#000"></path>
                    </mask>
                </defs>
            </g>
        </svg>

        <!-- Title -->
        <h1 class="svg-title text-2xl font-semibold text-slate-100" style="font-family: 'Rostex', sans-serif;">
            <span class="svg-chunk">
                <span class="svg-main">S</span><span class="svg-extra text-base">calable</span>
            </span>

            <span class="svg-chunk">
                <span class="svg-main">V</span><span class="svg-extra text-base">ector</span>
            </span>

            <span class="svg-chunk">
                <span class="svg-main">G</span><span class="svg-extra text-base">raphics</span>
            </span>
        </h1>
    </div>

    <p class="text-xs text-slate-500 mb-1">
        Design custom bento shapes, clip images, and export as SVG/PNG.
    </p>

    <!-- Tabs -->
    <div class="relative border-b border-slate-800 mb-2">

        <!-- Animated underline -->
        <div id="toolbarTabIndicator" class="absolute bottom-0 h-[2px] rounded transition-all duration-300 ease-out" style="background: var(--color-primary1);"></div>

        <div class="flex text-xs relative">
            <button id="toolbarTabCanvasBtn" data-tab-button data-tab-target="toolbarTabCanvas" class="tab-btn px-3 py-2 text-slate-100 font-medium" data-index="0">
                Canvas
            </button>

            <button id="toolbarTabShapeBtn" data-tab-button data-tab-target="toolbarTabShape" class="tab-btn px-3 py-2 text-slate-400 hover:text-slate-200" data-index="1">
                Shape
            </button>

            <button id="toolbarTabImageBtn" data-tab-button data-tab-target="toolbarTabImage" class="tab-btn px-3 py-2 text-slate-400 hover:text-slate-200" data-index="2">
                Image
            </button>

            <button id="toolbarTabExportBtn" data-tab-button data-tab-target="toolbarTabExport" class="tab-btn px-3 py-2 text-slate-400 hover:text-slate-200" data-index="3">
                Export
            </button>
        </div>
    </div>

    <!-- TAB 1: Canvas & Layout (default visible) -->
    <div id="toolbarTabCanvas" data-tab-panel class="flex flex-col gap-4">

        <!-- Canvas dimensions -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-slate-300">
                    Canvas size <span class="text-[11px] text-slate-500">px</span>
                </label>
            </div>

            <div class="flex items-center gap-3">

                <!-- Width -->
                <div class="flex-1">
                    <label for="canvasWidthInput" class="block text-[11px] text-slate-400 mb-1">
                        Width
                    </label>
                    <input id="canvasWidthInput" type="number" min="1" class="w-full h-[38px] rounded-xl border border-slate-300 bg-white px-3 text-sm text-slate-800 focus:outline-none focus:ring-1 focus:ring-blue-400" value="1000" />
                </div>

                <!-- PERFECTLY centered × -->
                <span class="flex items-center justify-center h-[38px] text-xs text-slate-500 leading-none translate-y-[10px]">
                    ×
                </span>

                <!-- Height -->
                <div class="flex-1">
                    <label for="canvasHeightInput" class="block text-[11px] text-slate-400 mb-1">
                        Height
                    </label>
                    <input id="canvasHeightInput" type="number" min="1" class="w-full h-[38px] rounded-xl border border-slate-300 bg-white px-3 text-sm text-slate-800 focus:outline-none focus:ring-1 focus:ring-blue-400" value="1000" />
                </div>
            </div>

            <div class="flex items-center justify-between">
                <label class="inline-flex items-center gap-2 text-[11px] text-slate-400">
                    <input id="canvasLockAspectToggle" type="checkbox" class="h-3 w-3 rounded border-slate-700 bg-slate-900" />
                    Lock aspect ratio
                </label>

                <select id="canvasPresetSelect" class="rounded-lg border border-slate-800 bg-slate-900 px-2 py-1 text-[11px] text-slate-300 focus:outline-none focus:ring-1 focus:ring-slate-500">
                    <option value="custom">Custom</option>
                    <option value="1:1">Square (1:1)</option>
                    <option value="4:5">Portrait (4:5)</option>
                    <option value="16:9">Landscape (16:9)</option>
                </select>
            </div>
        </div>

        <!-- Background -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-slate-300">
                    Background
                </label>
            </div>

            <div class="flex items-center justify-between text-[11px]">
                <label class="inline-flex items-center gap-2 text-slate-400">
                    <input id="bgCheckerToggle" type="checkbox" checked class="h-3 w-3 rounded border-slate-700 bg-slate-900" />
                    Use checkerboard
                </label>

                <div class="flex items-center gap-2">
                    <span class="text-slate-400">Canvas colour (when off)</span>
                    <input id="bgColorInput" type="color" value="#FDFDFD" class="h-5 w-8 cursor-pointer rounded border border-slate-700 bg-slate-900 p-0" />
                </div>
            </div>
        </div>

        <!-- Export background (moved from Export tab) -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-slate-300">
                    Export background
                </label>
            </div>
            <div class="space-y-1 text-[11px] text-slate-400">
                <label class="inline-flex items-center gap-2">
                    <input id="exportTransparentBgToggle" type="checkbox" checked class="h-3 w-3 rounded border-slate-700 bg-slate-900" />
                    Transparent background
                </label>
                <div class="flex items-center justify-between">
                    <label class="inline-flex items-center gap-2">
                        <input id="exportSolidBgToggle" type="checkbox" class="h-3 w-3 rounded border-slate-700 bg-slate-900" />
                        Solid background
                    </label>
                    <input id="exportBgColorInput" type="color" value="#FDFDFD" class="h-5 w-8 cursor-pointer rounded border border-slate-700 bg-slate-900 p-0" />
                </div>
                <p class="text-[11px] text-slate-500">
                    These settings affect the background of exported SVG/PNG.
                </p>
            </div>
        </div>
    </div>

    <!-- TAB 2: Shape & Points -->
    <div id="toolbarTabShape" data-tab-panel class="hidden flex flex-col gap-4">
        <!-- Active Shape Selector -->
        <div class="space-y-2">
            <label class="text-sm font-medium text-slate-300">
                Active Shape
            </label>
            <div class="grid grid-cols-3 gap-2">
                <button id="shapeSelectBtn1" data-shape-index="0" class="shape-select-btn text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 shape-select-btn-active">
                    Shape 1
                </button>
                <button id="shapeSelectBtn2" data-shape-index="1" class="shape-select-btn text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                    Shape 2
                </button>
                <button id="shapeSelectBtn3" data-shape-index="2" class="shape-select-btn text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                    Shape 3
                </button>
            </div>
        </div>

        <!-- Mode (geometry only) -->
        <div class="space-y-2">
            <div class="inline-flex rounded-full bg-slate-900 p-1 text-xs">
                <button id="modeMove" class="px-3 py-1 rounded-full bg-slate-100 text-slate-900 font-medium">
                    Move points
                </button>
                <button id="modeAdd" class="px-3 py-1 rounded-full text-slate-300">
                    Add points
                </button>
            </div>
            <p class="text-xs text-slate-500">
                Applies to active shape. Move: drag handles · Add: click path to insert new points.
            </p>
        </div>

        <!-- Corner radius (selected point) -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-slate-300">
                    Corner radius (selected point)
                </label>
                <span id="radiusLabel" class="text-xs text-slate-400"></span>
            </div>
            <input id="radiusSlider" type="range" min="0" max="250" step="5" class="w-full accent-slate-100" />
            <p class="text-xs text-slate-500">
                Click a point on the active shape to select it.
            </p>
        </div>

        <!-- Global corner radius -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-slate-300">
                    Global corner radius (active shape)
                </label>
                <button id="globalRadiusResetBtn" class="text-[11px] text-slate-400 hover:text-slate-200 underline decoration-dotted">
                    Reset
                </button>
            </div>
            <input id="globalRadiusSlider" type="range" min="0" max="250" step="5" class="w-full accent-slate-100" />
            <p class="text-[11px] text-slate-500">
                Apply a uniform radius to all points on the active shape.
            </p>
        </div>

        <!-- Point management -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <span class="text-sm font-medium text-slate-300">Points (active shape)</span>
            </div>
            <div class="flex gap-2">
                <button id="deletePointBtn" class="flex-1 text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                    Delete selected point
                </button>
                <button id="smoothAllBtn" class="flex-1 text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                    Smooth all
                </button>
            </div>
            <button id="sharpAllBtn" class="w-full text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                Make all corners sharp
            </button>
            <!-- Point Coordinates -->
            <div class="space-y-1 pt-2">
                <label class="text-xs text-slate-400">Point Coordinates (active shape)</label>
                <div id="pointsList" class="max-h-40 overflow-y-auto rounded-lg border border-slate-800 bg-slate-900/60 p-2 text-[11px] leading-relaxed text-slate-300">
                    <!-- Rows inserted dynamically -->
                </div>
            </div>
        </div>

        <!-- Stroke / border styling -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <span class="text-sm font-medium text-slate-300">Frame style (active shape)</span>
            </div>
            <div class="flex items-center justify-between text-[11px] text-slate-400">
                <div class="flex items-center gap-2">
                    <span>Stroke</span>
                    <input id="frameStrokeColorInput" type="color" value="#82a4f8" class="h-5 w-8 cursor-pointer rounded border border-slate-700 bg-slate-900 p-0" />
                </div>
                <div class="flex items-center gap-2">
                    <span>Width</span>
                    <input id="frameStrokeWidthSlider" type="range" min="0" max="20" step="1" class="w-24 accent-slate-100" />
                </div>
            </div>
            <div class="flex items-center justify-between text-[11px] text-slate-400">
                <div class="flex items-center gap-2">
                    <span>Style</span>
                    <select id="frameStrokeStyleSelect" class="rounded-lg border border-slate-800 bg-slate-900 px-2 py-1 text-[11px] text-slate-300 focus:outline-none focus:ring-1 focus:ring-slate-500">
                        <option value="solid">Solid</option>
                        <option value="dashed">Dashed</option>
                        <option value="dotted">Dotted</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Shape presets -->
        <div class="space-y-3">
            <div class="flex items-center justify-between">
                <span class="text-sm font-medium text-slate-300">Quick Shapes (for active shape)</span>
            </div>

            <!-- Horizontal scroll row -->
            <div class="flex gap-1 overflow-x-auto pb-2 pr-2 scrollbar-hide whitespace-nowrap min-w-0">
                <button id="presetRectBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Rectangle
                </button>
                <button id="presetCircleBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Notch
                </button>
                <button id="presetPillBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Double Notch
                </button>
                <button id="presetNotchBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Notch Right
                </button>
                <button id="presetTriangleBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Triangle
                </button>
                <button id="presetHexagonBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Hexagon
                </button>
                <button id="presetStarBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Star
                </button>
                <button id="presetDiamondBtn" class="flex-shrink-0 px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 hover:bg-slate-800 transition-colors text-xs">
                    Diamond
                </button>
            </div>
        </div>

        <!-- Reset frame -->
        <div class="space-y-2">
            <button id="resetBtn" class="w-full text-sm px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                Reset frame (active shape)
            </button>
        </div>
    </div>

    <!-- TAB 3: Image -->
    <div id="toolbarTabImage" data-tab-panel class="hidden flex flex-col gap-4">
        <!-- Image upload -->
        <div class="space-y-2">
            <label class="text-sm font-medium text-slate-300">Image (for active shape)</label>

            <!-- Local file input -->
            <input id="fileInput" type="file" accept="image/*" class="block w-full text-sm cursor-pointer
               file:mr-4 file:py-1.5 file:px-3
               file:rounded-full file:border-0
               file:text-sm file:font-semibold
               file:bg-slate-100 file:text-slate-900
               hover:file:bg-slate-200" />

            <!-- URL import -->
            <div class="space-y-1">
                <label for="imageUrlInput" class="text-xs text-slate-400">
                    Or load from image URL
                </label>

                <div class="flex items-center gap-2">
                    <input id="imageUrlInput" type="url" placeholder="https://example.com/image.png" class="flex-1 rounded-lg border border-slate-800 bg-slate-900
             px-3 py-1.5 text-xs text-slate-100
             focus:outline-none focus:ring-1 focus:ring-slate-500" />
                    <button id="loadImageFromUrlBtn" class="px-3 py-1.5 rounded-lg text-xs font-medium
             bg-slate-800 border border-slate-700
             hover:bg-slate-700 text-slate-200 transition">
                        Load
                    </button>
                </div>

                <!-- Skeleton: hidden by default -->
                <div id="imageUrlSkeleton" class="hidden h-1.5 rounded-full bg-slate-800 overflow-hidden">
                    <div class="h-full w-1/3 bg-slate-500/60 animate-[pulse_1s_ease-in-out_infinite]"></div>
                </div>
            </div>
        </div>

        <!-- Image zoom & fit -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-slate-300">
                    Image zoom (active shape)
                </label>
                <span id="zoomLabel" class="text-xs text-slate-400"></span>
            </div>
            <input id="zoomSlider" type="range" min="50" max="300" step="5" class="w-full accent-slate-100" />
            <div class="flex items-center justify-between text-[11px] text-slate-400">
                <div class="flex items-center gap-2">
                    <span>Fit</span>
                    <select id="imageFitSelect" class="rounded-lg border border-slate-800 bg-slate-900 px-2 py-1 text-[11px] text-slate-300 focus:outline-none focus:ring-1 focus:ring-slate-500">
                        <option value="cover">Cover (crop)</option>
                        <option value="contain">Contain</option>
                        <option value="stretch">Stretch</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <span>Opacity</span>
                    <input id="imageOpacitySlider" type="range" min="0" max="100" step="5" class="w-24 accent-slate-100" />
                </div>
            </div>
            <button id="viewportResetBtn" class="w-full text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                Reset image transform
            </button>
        </div>

        <!-- Image interaction mode -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-slate-300">
                    Image interactions
                </label>
            </div>
            <div class="inline-flex rounded-full bg-slate-900 p-1 text-xs">
                <button id="modePan" class="px-3 py-1 rounded-full text-slate-300">
                    Pan image
                </button>
            </div>
            <p class="text-xs text-slate-500">
                Enable pan, then drag inside the canvas to move the image within the active shape.
            </p>
        </div>
    </div>

    <!-- TAB 4: Export -->
    <div id="toolbarTabExport" data-tab-panel class="hidden flex flex-col gap-4">
        <!-- Export options -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <span class="text-sm font-medium text-slate-300">Export options</span>
            </div>

            <div class="space-y-1 text-[11px] text-slate-400">
                <label class="inline-flex items-center gap-2">
                    <input id="exportIncludeFrameToggle" type="checkbox" checked class="h-3 w-3 rounded border-slate-700 bg-slate-900" />
                    Include frame strokes (per-shape style)
                </label>
            </div>
        </div>

        <!-- Export size & filename -->
        <div class="space-y-2">
            <div class="flex items-center justify-between">
                <span class="text-sm font-medium text-slate-300">Export size</span>
            </div>
            <div class="flex items-center justify-between text-[11px] text-slate-400 mb-1">
                <label class="inline-flex items-center gap-2">
                    <input id="exportUseCanvasSizeToggle" type="checkbox" checked class="h-3 w-3 rounded border-slate-700 bg-slate-900" />
                    Use canvas size
                </label>
            </div>
            <div class="flex items-center gap-2 text-[11px]">
                <input id="exportWidthInput" type="number" min="1" class="w-full rounded-lg border border-slate-800 bg-slate-900 px-2 py-1.5 text-xs text-slate-100 focus:outline-none focus:ring-1 focus:ring-slate-500" placeholder="Width" />
                <span class="text-slate-500">×</span>
                <input id="exportHeightInput" type="number" min="1" class="w-full rounded-lg border border-slate-800 bg-slate-900 px-2 py-1.5 text-xs text-slate-100 focus:outline-none focus:ring-1 focus:ring-slate-500" placeholder="Height" />
            </div>
            <div class="space-y-1">
                <label class="text-[11px] text-slate-400" for="exportFileNameInput">
                    File name
                </label>
                <input id="exportFileNameInput" type="text" class="w-full rounded-lg border border-slate-800 bg-slate-900 px-2 py-1.5 text-xs text-slate-100 focus:outline-none focus:ring-1 focus:ring-slate-500" value="bento-shapes" />
            </div>
        </div>

        <!-- Export buttons -->
        <div class="space-y-2">
            <div class="flex gap-2">
                <button id="exportSvgBtn" class="flex-1 text-xs px-3 py-2 rounded-xl bg-slate-100 text-slate-900 font-medium hover:bg-slate-200">
                    Download SVG
                </button>
                <button id="exportPngBtn" class="flex-1 text-xs px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800">
                    Download PNG
                </button>
            </div>
        </div>
    </div>
</div>

    </div>

    <!-- CONFIG -->
    <script>
        // ----- CONFIG -----
        const DEFAULT_VIEWBOX_SIZE = 1000;
        const INITIAL_MARGIN = 10; 
        const INITIAL_RADIUS = 80;
        const MAX_SHAPES = 3;

        // Dynamic viewbox
        let viewBoxWidth = DEFAULT_VIEWBOX_SIZE;
        let viewBoxHeight = DEFAULT_VIEWBOX_SIZE;

        // ----- STATE -----
        /**
         * Shape Object: {
         * id: string,
         * points: [ { x, y, radius } ],
         * image: {
         * href: string,
         * dataUrl: string,
         * fileName: string,
         * scale: number,
         * offsetX: number,
         * offsetY: number,
         * opacity: number,
         * fit: string
         * },
         * frame: {
         * stroke: string,
         * strokeWidth: number,
         * strokeStyle: string
         * }
         * }
         */
        let shapes = [];
        let activeShapeIndex = 0;
        let selectedPointIndex = null; // Index into the *active* shape's points array

        let currentMode = "move"; // "move" | "add" | "panImage"

        // Point dragging (no offset -> point snaps under cursor)
        const draggingPoint = {
            index: null,
            pointerId: null,
        };

        // Image panning state (applies to active shape)
        const draggingImage = {
            active: false,
            pointerId: null,
            startX: 0,
            startY: 0,
            startOffsetX: 0,
            startOffsetY: 0,
        };

        // ----- DOM REFS -----
        // SVG + layers
        const svg = document.getElementById("editor");
        const svgDefs = svg.querySelector("defs");
        const shapeLayersGroup = document.getElementById("shapeLayers");
        const handlesGroup = document.getElementById("handles");
        const backgroundRect = document.getElementById("checkerBackground");

        // Canvas tab
        const shapeSelectBtn1 = document.getElementById("shapeSelectBtn1");
        const shapeSelectBtn2 = document.getElementById("shapeSelectBtn2");
        const shapeSelectBtn3 = document.getElementById("shapeSelectBtn3");
        const shapeSelectBtns = [shapeSelectBtn1, shapeSelectBtn2, shapeSelectBtn3];

        const canvasWidthInput = document.getElementById("canvasWidthInput");
        const canvasHeightInput = document.getElementById("canvasHeightInput");
        const canvasLockAspectToggle = document.getElementById("canvasLockAspectToggle");
        const canvasPresetSelect = document.getElementById("canvasPresetSelect");
        const bgCheckerToggle = document.getElementById("bgCheckerToggle");
        const bgColorInput = document.getElementById("bgColorInput");
        const viewportResetBtn = document.getElementById("viewportResetBtn");
        const canvasLoadingOverlay = document.getElementById("canvasLoadingOverlay");


        // Shape tab
        const modeMoveBtn = document.getElementById("modeMove");
        const modeAddBtn = document.getElementById("modeAdd");
        const modePanBtn = document.getElementById("modePan");

        const radiusSlider = document.getElementById("radiusSlider");
        const radiusLabel = document.getElementById("radiusLabel");

        const globalRadiusSlider = document.getElementById("globalRadiusSlider");
        const globalRadiusResetBtn = document.getElementById("globalRadiusResetBtn");

        const deletePointBtn = document.getElementById("deletePointBtn");
        const smoothAllBtn = document.getElementById("smoothAllBtn");
        const sharpAllBtn = document.getElementById("sharpAllBtn");

        const frameStrokeColorInput = document.getElementById("frameStrokeColorInput");
        const frameStrokeWidthSlider = document.getElementById(
            "frameStrokeWidthSlider"
        );
        const frameStrokeStyleSelect = document.getElementById(
            "frameStrokeStyleSelect"
        );
      
        // Few SVGs
        const presetRectBtn = document.getElementById("presetRectBtn");
        const presetCircleBtn = document.getElementById("presetCircleBtn");
        const presetPillBtn = document.getElementById("presetPillBtn");
        const presetNotchBtn = document.getElementById("presetNotchBtn");
        const presetTriangleBtn = document.getElementById("presetTriangleBtn");
        const presetHexagonBtn = document.getElementById("presetHexagonBtn");
        const presetStarBtn = document.getElementById("presetStarBtn");
        const presetDiamondBtn = document.getElementById("presetDiamondBtn");

        // Point coordinates list
        const pointsListEl = document.getElementById("pointsList");
        const SNAP_THRESHOLD = 10;

        // Image & export tab
        const fileInput = document.getElementById("fileInput");
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomLabel = document.getElementById("zoomLabel");
        const imageFitSelect = document.getElementById("imageFitSelect");
        const imageOpacitySlider = document.getElementById("imageOpacitySlider");
        const imageResetBtn = document.getElementById("imageResetBtn");

        const exportIncludeFrameToggle = document.getElementById(
            "exportIncludeFrameToggle"
        );
        const exportTransparentBgToggle = document.getElementById(
            "exportTransparentBgToggle"
        );
        const exportSolidBgToggle =
            document.getElementById("exportSolidBgToggle");
        const exportBgColorInput =
            document.getElementById("exportBgColorInput");

        const exportUseCanvasSizeToggle = document.getElementById(
            "exportUseCanvasSizeToggle"
        );
        const exportWidthInput = document.getElementById("exportWidthInput");
        const exportHeightInput = document.getElementById("exportHeightInput");
        const exportFileNameInput = document.getElementById("exportFileNameInput");

        const exportSvgBtn = document.getElementById("exportSvgBtn");
        const exportPngBtn = document.getElementById("exportPngBtn");

        // Shared footer
        const resetBtn = document.getElementById("resetBtn");

        // Small tooltip for showing point coordinates while dragging
        const sizeTooltip = document.createElement("div");
        sizeTooltip.style.position = "fixed";
        sizeTooltip.style.pointerEvents = "none";
        sizeTooltip.style.zIndex = "9999";
        sizeTooltip.style.fontSize = "11px";
        sizeTooltip.style.fontFamily =
            "system-ui, -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif";
        sizeTooltip.style.padding = "4px 8px"; // Increased padding
        sizeTooltip.style.borderRadius = "6px"; // Changed from pill
        sizeTooltip.style.background = "rgba(253, 253, 253, 0.98)";
        sizeTooltip.style.color = "#1B1B1B";
        sizeTooltip.style.border = "1px solid rgba(231, 231, 231, 0.9)";
        sizeTooltip.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.08)";

        sizeTooltip.style.transform = "translate(10px, 10px)";
        sizeTooltip.style.display = "none";
        document.body.appendChild(sizeTooltip);
    </script>

    <!-- STATE MANAGEMENT & HELPERS -->
    <script>
        function createDefaultShape(id) {
            return {
                id: id,
                points: [],
                image: {
                    href: "",
                    dataUrl: "",
                    fileName: "image.png",
                    scale: 1,
                    offsetX: 0,
                    offsetY: 0,
                    opacity: 1,
                    fit: 'cover'
                },
                frame: {
                    stroke: '#60a9ff',
                    strokeWidth: 4,
                    strokeStyle: 'solid'
                }
            };
        }

        function getActiveShape() {
            return shapes[activeShapeIndex];
        }

        
        //  Updates all UI controls (sliders, colors, etc.) to match the state of the currently active shape. 
        
        function syncUiToActiveShape() {
            const shape = getActiveShape();
            if (!shape) return;

            // --- Shape Tab ---
            updateRadiusSliderFromSelected(); // Handles selected point radius
            // Update global radius slider (use average radius as a guess)
            if (globalRadiusSlider) {
                if (shape.points.length > 0) {
                    const avgRadius = shape.points.reduce((acc, p) => acc + (p.radius || 0), 0) / shape.points.length;
                    globalRadiusSlider.value = avgRadius;
                } else {
                    globalRadiusSlider.value = 0;
                }
            }
            // Update frame style controls
            if (frameStrokeColorInput) frameStrokeColorInput.value = shape.frame.stroke;
            if (frameStrokeWidthSlider) frameStrokeWidthSlider.value = shape.frame.strokeWidth;
            if (frameStrokeStyleSelect) frameStrokeStyleSelect.value = shape.frame.strokeStyle;

            // --- Image Tab ---
            if (zoomSlider) zoomSlider.value = shape.image.scale * 100;
            updateZoomLabel();
            if (imageFitSelect) imageFitSelect.value = shape.image.fit;
            if (imageOpacitySlider) imageOpacitySlider.value = shape.image.opacity * 100;

            // Clear file input, as it doesn't represent the loaded image
            if (fileInput) fileInput.value = "";
            if (imageUrlInput) imageUrlInput.value = "";

            // --- Update Canvas ---
            renderActiveShape();
        }

         // Sets the active shape index and updates the UI.

        function setActiveShape(index) {
            if (index < 0 || index >= MAX_SHAPES) return;

            activeShapeIndex = index;
            selectedPointIndex = null; // Deselect points when switching shapes

            // Update button styles
            shapeSelectBtns.forEach((btn, i) => {
                btn.classList.toggle("shape-select-btn-active", i === index);
            });

            // Update all controls to match this shape's state
            syncUiToActiveShape();
        }
    </script>

    <!-- VIEWBOX / CANVAS -->
    <script>
        function updateViewBox() {
            svg.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
            if (backgroundRect) {
                backgroundRect.setAttribute("width", viewBoxWidth);
                backgroundRect.setAttribute("height", viewBoxHeight);
            }
            // Update all shapes' transforms
            shapes.forEach(shape => updateImageTransform(shape));
            renderActiveShape(); // Re-render active shape
        }

        function applyCanvasSizeFromInputs() {
            const w = parseFloat(canvasWidthInput?.value || "") || viewBoxWidth;
            const h = parseFloat(canvasHeightInput?.value || "") || viewBoxHeight;
            const lockAspect = !!canvasLockAspectToggle?.checked;

            let newW = Math.max(1, w);
            let newH = Math.max(1, h);

            if (lockAspect) {
                const currentRatio = viewBoxWidth / viewBoxHeight || 1;
                // If width changed, adjust height to keep ratio
                if (w !== viewBoxWidth) {
                    newH = Math.round(newW / currentRatio);
                    if (canvasHeightInput) canvasHeightInput.value = newH;
                } else if (h !== viewBoxHeight) {
                    newW = Math.round(newH * currentRatio);
                    if (canvasWidthInput) canvasWidthInput.value = newW;
                }
            }

            viewBoxWidth = newW;
            viewBoxHeight = newH;
            updateViewBox();
        }

        function applyCanvasPreset() {
            if (!canvasPresetSelect) return;
            const value = canvasPresetSelect.value;
            let ratio = null;

            if (value === "1:1") ratio = 1;
            if (value === "4:5") ratio = 4 / 5;
            if (value === "16:9") ratio = 16 / 9;

            if (!ratio) return;

            const baseWidth =
                parseFloat(canvasWidthInput?.value || "") || viewBoxWidth;
            const newW = Math.max(1, baseWidth);
            const newH = Math.round(newW / ratio);

            if (canvasWidthInput) canvasWidthInput.value = newW;
            if (canvasHeightInput) canvasHeightInput.value = newH;

            viewBoxWidth = newW;
            viewBoxHeight = newH;
            updateViewBox();
        }

        // ----- FRAME SHAPE -----
        
         // Resets the points of a specific shape object to a default rectangle.

        function resetFrame(shape) {
            if (!shape) return;
            // Place shapes at different positions
            let m = INITIAL_MARGIN;
            if (shape.id === 'shape-2') m = INITIAL_MARGIN + 100;
            if (shape.id === 'shape-3') m = INITIAL_MARGIN + 200;

            shape.points = [{
                    x: m,
                    y: m,
                    radius: INITIAL_RADIUS
                },
                {
                    x: viewBoxWidth - m,
                    y: m,
                    radius: INITIAL_RADIUS
                },
                {
                    x: viewBoxWidth - m,
                    y: viewBoxHeight - m,
                    radius: INITIAL_RADIUS,
                },
                {
                    x: m,
                    y: viewBoxHeight - m,
                    radius: INITIAL_RADIUS
                },
            ];
            selectedPointIndex = 0;

            renderActiveShape();
            updateRadiusSliderFromSelected();
        }

       
         // Renders the path, frame, and handles for the *currently active* shape.

        function renderActiveShape() {
            const shape = getActiveShape();
            if (!shape) {
                handlesGroup.innerHTML = ""; // Clear handles if no shape
                return;
            }

            const clipPathEl = document.getElementById("clipPath-" + shape.id);
            const framePathEl = document.getElementById("framePath-" + shape.id);

            if (!clipPathEl || !framePathEl) return; // Elements not ready

            const d = buildRoundedPath(shape.points);
            clipPathEl.setAttribute("d", d);
            framePathEl.setAttribute("d", d);

            // Apply the specific frame style for this shape
            applyFrameStyleToElement(framePathEl, shape.frame);

            renderHandles();
            updateImageTransform(shape);
            renderPointsList(); // update coordinates panel
        }

        function renderHandles() {
            // Clear old handles
            handlesGroup.innerHTML = "";

            const shape = getActiveShape();
            if (!shape) return;

            shape.points.forEach((pt, i) => {
                const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                c.setAttribute("class", "handle");
                c.setAttribute("cx", pt.x);
                c.setAttribute("cy", pt.y);
                c.setAttribute("r", 7);
                c.setAttribute("fill", "var(--color-bg-surface3)");
                c.setAttribute("stroke", "#2D68FF");

                c.setAttribute("stroke-width", "2");
                if (i === selectedPointIndex) {
                    c.classList.add("selected");
                }
                if (i === draggingPoint.index) {
                    c.classList.add("dragging");
                }
                c.dataset.index = i;
                c.addEventListener("pointerdown", onHandlePointerDown);
                handlesGroup.appendChild(c);
            });
        }

        //  POINTS LIST / COORDINATES
        function renderPointsList() {
            if (!pointsListEl) return;
            pointsListEl.innerHTML = "";

            const shape = getActiveShape();
            if (!shape) return;

            shape.points.forEach((pt, i) => {
                const row = document.createElement("div");

                // base classes + our custom row class
                row.className =
                    "flex justify-between items-center py-1 px-2 rounded cursor-pointer transition point-row";

                // selected state
                if (i === selectedPointIndex) {
                    row.classList.add("point-row-selected");
                }

                row.innerHTML = `
            <div>Point ${i + 1}</div>
            <div class="point-row-coord">
                x: ${pt.x.toFixed(0)}, y: ${pt.y.toFixed(0)}
            </div>
        `;

                row.addEventListener("click", () => {
                    selectPoint(i);
                });

                pointsListEl.appendChild(row);
            });
        }


        // Build rounded polygon path (closed) from points array (per-point radius)
        function buildRoundedPath(pts) {
            const n = pts.length;
            if (n === 0) return "";
            if (n === 1) return `M ${pts[0].x} ${pts[0].y}`;
            if (n === 2) return `M ${pts[0].x} ${pts[0].y} L ${pts[1].x} ${pts[1].y}`;

            const B1 = [];
            const B2 = [];

            // Precompute the "cut" points for each vertex using its own radius
            for (let i = 0; i < n; i++) {
                const prev = pts[(i - 1 + n) % n];
                const curr = pts[i];
                const next = pts[(i + 1) % n];

                const v1x = curr.x - prev.x;
                const v1y = curr.y - prev.y;
                const v2x = next.x - curr.x;
                const v2y = next.y - curr.y;

                const len1 = Math.hypot(v1x, v1y);
                const len2 = Math.hypot(v2x, v2y);

                const r = Math.max(0, curr.radius || 0);

                if (len1 === 0 || len2 === 0 || r === 0) {
                    // Degenerate or sharp corner: no rounding
                    B1.push({
                        x: curr.x,
                        y: curr.y
                    });
                    B2.push({
                        x: curr.x,
                        y: curr.y
                    });
                    continue;
                }

                const r1 = Math.min(r, len1 / 2);
                const r2 = Math.min(r, len2 / 2);

                const b1x = curr.x - (v1x / len1) * r1;
                const b1y = curr.y - (v1y / len1) * r1;
                const b2x = curr.x + (v2x / len2) * r2;
                const b2y = curr.y + (v2y / len2) * r2;

                B1.push({
                    x: b1x,
                    y: b1y
                });
                B2.push({
                    x: b2x,
                    y: b2y
                });
            }

            let d = "";
            // Start at end of last rounded corner
            d += `M ${B2[n - 1].x.toFixed(2)} ${B2[n - 1].y.toFixed(2)} `;
            for (let i = 0; i < n; i++) {
                const b1 = B1[i];
                const vertex = pts[i];
                const b2 = B2[i];
                d += `L ${b1.x.toFixed(2)} ${b1.y.toFixed(2)} `;
                // Quadratic curve for the rounded corner
                d += `Q ${vertex.x.toFixed(2)} ${vertex.y.toFixed(2)} ${b2.x.toFixed(
      2
    )} ${b2.y.toFixed(2)} `;
            }
            d += "Z";
            return d;
        }
    </script>

    <!-- MODES -->
    <script>
        function setMode(mode) {
            currentMode = mode;

            const activeClasses = ["bg-slate-100", "text-slate-900", "font-medium"];
            const inactiveText = ["text-slate-300"];

            function setBtn(btn, active) {
                if (!btn) return;
                btn.classList.remove(...activeClasses, ...inactiveText);
                if (active) {
                    btn.classList.add(...activeClasses);
                } else {
                    btn.classList.add(...inactiveText);
                }
            }

            setBtn(modeMoveBtn, mode === "move");
            setBtn(modeAddBtn, mode === "add");
            setBtn(modePanBtn, mode === "panImage");
        }

        // ----- EVENTS: SVG / DRAGGING -----
        function onHandlePointerDown(e) {
            e.stopPropagation();
            e.preventDefault();

            const idx = parseInt(e.target.dataset.index, 10);
            selectPoint(idx);

            if (currentMode !== "move") {
                // Only select in other modes, no drag
                return;
            }

            draggingPoint.index = idx;
            draggingPoint.pointerId = e.pointerId;

            e.target.classList.add("dragging");

            svg.setPointerCapture(e.pointerId);
        }

        function onSvgPointerDown(e) {
            const shape = getActiveShape();
            if (!shape) return;

            // Add-point mode: click on shape to insert a new point
            if (currentMode === "add") {
                if (e.target.classList.contains("handle")) return;
                const pt = getSvgPoint(e);
                insertPointAt(pt.x, pt.y);
                selectPoint(findClosestPointIndex(pt.x, pt.y));
                renderActiveShape();
                return;
            }

            // Pan-image mode
            if (currentMode === "panImage") {
                if (e.target.classList.contains("handle")) return;
                const pt = getSvgPoint(e);
                draggingImage.active = true;
                draggingImage.pointerId = e.pointerId;
                draggingImage.startX = pt.x;
                draggingImage.startY = pt.y;
                draggingImage.startOffsetX = shape.image.offsetX;
                draggingImage.startOffsetY = shape.image.offsetY;

                svg.setPointerCapture(e.pointerId);
                return;
            }
        }

        function onSvgPointerMove(e) {
            const shape = getActiveShape();
            if (!shape) return;

            // Point dragging - directly set to cursor position
            if (draggingPoint.index !== null) {
                const svgPoint = getSvgPoint(e);
                let clamped = clampToViewBox({
                    x: svgPoint.x,
                    y: svgPoint.y,
                });

                // Apply snapping to other points if close enough
                clamped = applyPointSnapping(clamped, draggingPoint.index);

                shape.points[draggingPoint.index].x = clamped.x;
                shape.points[draggingPoint.index].y = clamped.y;

                renderActiveShape();
                updateSizeTooltip(e);

                return;
            }

            // Image dragging
            if (draggingImage.active) {
                const pt = getSvgPoint(e);
                const dx = pt.x - draggingImage.startX;
                const dy = pt.y - draggingImage.startY;
                shape.image.offsetX = draggingImage.startOffsetX + dx;
                shape.image.offsetY = draggingImage.startOffsetY + dy;
                updateImageTransform(shape);
            }
        }

        function onSvgPointerUp(e) {
            if (
                draggingPoint.pointerId !== null &&
                e.pointerId === draggingPoint.pointerId
            ) {
                document.querySelectorAll(".handle.dragging").forEach((handle) => {
                    handle.classList.remove("dragging");
                });

                try {
                    svg.releasePointerCapture(draggingPoint.pointerId);
                } catch {}
                draggingPoint.index = null;
                draggingPoint.pointerId = null;

                // Hide tooltip when we stop dragging a point
                sizeTooltip.style.display = "none";
            }

            if (draggingImage.active && e.pointerId === draggingImage.pointerId) {
                try {
                    svg.releasePointerCapture(draggingImage.pointerId);
                } catch {}
                draggingImage.active = false;
                draggingImage.pointerId = null;
            }
        }

        // Convert client coords -> SVG coords (no bouncing)
        function getSvgPoint(evt) {
            const rect = svg.getBoundingClientRect();

            const scaleX = viewBoxWidth / rect.width;
            const scaleY = viewBoxHeight / rect.height;

            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY,
            };
        }

        function clampToViewBox(pt) {
            return {
                x: Math.max(0, Math.min(viewBoxWidth, pt.x)),
                y: Math.max(0, Math.min(viewBoxHeight, pt.y)),
            };
        }

        function applyPointSnapping(pt, index) {
            const shape = getActiveShape();
            if (!shape) return pt;

            // pt: { x, y } current (clamped) cursor position in SVG coords
            // index: which point is being dragged

            let snappedX = pt.x;
            let snappedY = pt.y;

            let bestDx = SNAP_THRESHOLD + 1;
            let bestDy = SNAP_THRESHOLD + 1;

            for (let i = 0; i < shape.points.length; i++) {
                if (i === index) continue; 
                const other = shape.points[i];

                const dx = Math.abs(other.x - pt.x);
                if (dx <= SNAP_THRESHOLD && dx < bestDx) {
                    bestDx = dx;
                    snappedX = other.x; // snap X to other point
                }

                const dy = Math.abs(other.y - pt.y);
                if (dy <= SNAP_THRESHOLD && dy < bestDy) {
                    bestDy = dy;
                    snappedY = other.y; // snap Y to other point
                }
            }

            return {
                x: snappedX,
                y: snappedY,
            };
        }

        // Insert a new point on the closest segment of the active shape
        function insertPointAt(x, y) {
            const shape = getActiveShape();
            if (!shape) return;

            if (shape.points.length < 2) {
                shape.points.push({
                    x,
                    y,
                    radius: INITIAL_RADIUS,
                });
                return;
            }

            let bestIndex = 0;
            let bestDist = Infinity;

            for (let i = 0; i < shape.points.length; i++) {
                const a = shape.points[i];
                const b = shape.points[(i + 1) % shape.points.length];
                const dist = pointToSegmentDistance(x, y, a.x, a.y, b.x, b.y);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestIndex = i + 1; // insert after i
                }
            }

            const prev = shape.points[(bestIndex - 1 + shape.points.length) % shape.points.length];
            const next = shape.points[bestIndex % shape.points.length];
            const avgRadius = (prev.radius + next.radius) / 2 || INITIAL_RADIUS;

            shape.points.splice(bestIndex, 0, {
                x,
                y,
                radius: avgRadius,
            });
        }

        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const vx = x2 - x1;
            const vy = y2 - y1;
            const wx = px - x1;
            const wy = py - y1;
            const len2 = vx * vx + vy * vy;
            if (len2 === 0) return Math.hypot(px - x1, py - y1);
            let t = (wx * vx + wy * vy) / len2;
            t = Math.max(0, Math.min(1, t));
            const projx = x1 + t * vx;
            const projy = y1 + t * vy;
            return Math.hypot(px - projx, py - projy);
        }

        function findClosestPointIndex(x, y) {
            const shape = getActiveShape();
            if (!shape) return 0;

            let bestIndex = 0;
            let bestDist = Infinity;
            for (let i = 0; i < shape.points.length; i++) {
                const d = Math.hypot(shape.points[i].x - x, shape.points[i].y - y);
                if (d < bestDist) {
                    bestDist = d;
                    bestIndex = i;
                }
            }
            return bestIndex;
        }

        // UPDATED TOOLTIP FUNCTION
        function updateSizeTooltip(evt) {
            if (!sizeTooltip) return;
            const shape = getActiveShape();
            if (!shape || draggingPoint.index == null || !shape.points[draggingPoint.index]) {
                sizeTooltip.style.display = "none";
                return;
            }

            const pt = shape.points[draggingPoint.index];

            // Calculate distances to edges
            const fromLeft = Math.round(pt.x);
            const fromRight = Math.round(viewBoxWidth - pt.x);
            const fromTop = Math.round(pt.y);
            const fromBottom = Math.round(viewBoxHeight - pt.y);

            // Use innerHTML to allow for line breaks and arrows
            // Using a simple table-like layout with divs
            sizeTooltip.innerHTML = `
                <div style="display: grid; grid-template-columns: auto auto; gap: 0px 8px; align-items: center;">
                    <span style="text-align: right;">&larr; ${fromLeft}</span>
                    <span>${fromRight} &rarr;</span>
                    
                    <span style="text-align: right;">&uarr; ${fromTop}</span>
                    <span>${fromBottom} &darr;</span>
                </div>
            `;

            // Adjust styling for multi-line content
            sizeTooltip.style.lineHeight = "1.5";
            sizeTooltip.style.textAlign = "left";

            // Position next to cursor
            sizeTooltip.style.left = `${evt.clientX + 12}px`;
            sizeTooltip.style.top = `${evt.clientY + 12}px`;
            sizeTooltip.style.display = "block";
        }
    </script>

    <!-- CORNER RADIUS UI + FRAME STYLE + SHAPE PRESETS -->
    <script>
        // ---------- SHAPE PRESETS DATA ----------
        const SHAPE_PRESETS = [{
                id: "rounded-rect",
                name: "Rounded rectangle",
                baseSize: {
                    width: 1000,
                    height: 1000
                },
                points: [{
                        x: 40,
                        y: 40,
                        radius: INITIAL_RADIUS
                    },
                    {
                        x: 960,
                        y: 40,
                        radius: INITIAL_RADIUS
                    },
                    {
                        x: 960,
                        y: 960,
                        radius: INITIAL_RADIUS
                    },
                    {
                        x: 40,
                        y: 960,
                        radius: INITIAL_RADIUS
                    }
                ],
                tags: ["basic", "frame"]
            },
            {
                id: "circle-8pt",
                name: "Circle (8 points)",
                baseSize: {
                    width: 1000,
                    height: 1000
                },
                points: [{
                        x: 20,
                        y: 20,
                        radius: 40
                    },
                    {
                        x: 290,
                        y: 20,
                        radius: 40
                    },
                    {
                        x: 350,
                        y: 93,
                        radius: 40
                    },
                    {
                        x: 630,
                        y: 93,
                        radius: 40
                    },
                    {
                        x: 690,
                        y: 20,
                        radius: 40
                    },
                    {
                        x: 980,
                        y: 20,
                        radius: 40
                    },
                    {
                        x: 980,
                        y: 543,
                        radius: 40
                    },
                    {
                        x: 20,
                        y: 543,
                        radius: 40
                    }
                ],
                tags: ["circle"]
            },
            {
                id: "pill-horizontal",
                name: "Pill horizontal",
                baseSize: {
                    width: 1000,
                    height: 1000
                },
                points: [{
                        x: 20,
                        y: 20,
                        radius: 20
                    },
                    {
                        x: 171,
                        y: 20,
                        radius: 20
                    },
                    {
                        x: 205,
                        y: 99,
                        radius: 20
                    },
                    {
                        x: 412,
                        y: 99,
                        radius: 20
                    },
                    {
                        x: 483,
                        y: 20,
                        radius: 20
                    },
                    {
                        x: 980,
                        y: 20,
                        radius: 20
                    },
                    {
                        x: 980,
                        y: 480,
                        radius: 20
                    },
                    {
                        x: 483,
                        y: 480,
                        radius: 20
                    },
                    {
                        x: 400,
                        y: 368,
                        radius: 20
                    },
                    {
                        x: 10,
                        y: 368,
                        radius: 20
                    }
                ],
                tags: ["pill", "badge"]
            },
            {
                id: "notch-right",
                name: "Notch (Right)",
                baseSize: {
                    width: 1000,
                    height: 400
                },
                points: [{
                        x: 0,
                        y: 0,
                        radius: 20
                    },
                    {
                        x: 393,
                        y: 0,
                        radius: 20
                    },
                    {
                        x: 467,
                        y: 80,
                        radius: 20
                    },
                    {
                        x: 1000,
                        y: 80,
                        radius: 20
                    },
                    {
                        x: 1000,
                        y: 400,
                        radius: 20
                    },
                    {
                        x: 0,
                        y: 400,
                        radius: 20
                    }
                ],
                tags: ["notch", "badge", "container"]
            },
            {
                id: "triangle",
                name: "Triangle",
                baseSize: {
                    width: 1000,
                    height: 1000
                },
                points: [{
                    x: 500,
                    y: 40,
                    radius: 40
                }, {
                    x: 960,
                    y: 960,
                    radius: 40
                }, {
                    x: 40,
                    y: 960,
                    radius: 40
                }]
            }, {
                id: "hexagon",
                name: "Hexagon",
                baseSize: {
                    width: 1000,
                    height: 866
                },
                points: [{
                    x: 250,
                    y: 0,
                    radius: 40
                }, {
                    x: 750,
                    y: 0,
                    radius: 40
                }, {
                    x: 1000,
                    y: 433,
                    radius: 40
                }, {
                    x: 750,
                    y: 866,
                    radius: 40
                }, {
                    x: 250,
                    y: 866,
                    radius: 40
                }, {
                    x: 0,
                    y: 433,
                    radius: 40
                }]
            }, {
                id: "star",
                name: "Star",
                baseSize: {
                    width: 1000,
                    height: 951
                },
                points: [{
                    x: 500,
                    y: 0,
                    radius: 20
                }, {
                    x: 618,
                    y: 365,
                    radius: 20
                }, {
                    x: 1000,
                    y: 365,
                    radius: 20
                }, {
                    x: 691,
                    y: 593,
                    radius: 20
                }, {
                    x: 809,
                    y: 951,
                    radius: 20
                }, {
                    x: 500,
                    y: 724,
                    radius: 20
                }, {
                    x: 191,
                    y: 951,
                    radius: 20
                }, {
                    x: 309,
                    y: 593,
                    radius: 20
                }, {
                    x: 0,
                    y: 365,
                    radius: 20
                }, {
                    x: 382,
                    y: 365,
                    radius: 20
                }]
            }, {
                id: "diamond",
                name: "Diamond",
                baseSize: {
                    width: 1000,
                    height: 1000
                },
                points: [{
                    x: 500,
                    y: 40,
                    radius: 40
                }, {
                    x: 960,
                    y: 500,
                    radius: 40
                }, {
                    x: 500,
                    y: 960,
                    radius: 40
                }, {
                    x: 40,
                    y: 500,
                    radius: 40
                }]
            }
        ];

       // let userShapePresets = [];  Not used yet, but here for future

        // Scale preset points from their baseSize into current viewBox dimensions
        function getScaledPointsFromPreset(preset) {
            const bw = preset.baseSize?.width || DEFAULT_VIEWBOX_SIZE;
            const bh = preset.baseSize?.height || DEFAULT_VIEWBOX_SIZE;

            const sx = viewBoxWidth / bw;
            const sy = viewBoxHeight / bh;
            const radiusScale = Math.min(sx, sy);

            return preset.points.map(p => ({
                x: p.x * sx,
                y: p.y * sy,
                radius: (p.radius || 0) * radiusScale
            }));
        }

        // ---------- CORNER RADIUS UI ----------

        function selectPoint(index) {
            const shape = getActiveShape();
            if (!shape || index == null || index < 0 || index >= shape.points.length) {
                selectedPointIndex = null;
                if (radiusSlider) radiusSlider.disabled = true;
                if (radiusLabel) radiusLabel.textContent = "No point selected";
                renderHandles();
                renderPointsList();
                return;
            }
            selectedPointIndex = index;
            if (radiusSlider) radiusSlider.disabled = false;
            updateRadiusSliderFromSelected();
            renderHandles();
            renderPointsList();
        }

        function updateRadiusSliderFromSelected() {
            if (!radiusSlider || !radiusLabel) return;
            const shape = getActiveShape();
            if (selectedPointIndex == null || !shape || shape.points.length === 0) {
                radiusLabel.textContent = "No point selected";
                radiusSlider.value = 0;
                radiusSlider.disabled = true;
                return;
            }
            const r = shape.points[selectedPointIndex].radius || 0;
            radiusSlider.value = r;
            radiusLabel.textContent = `${r.toFixed(0)} px`;
            radiusSlider.disabled = false;
        }

        function onRadiusChange(e) {
            if (selectedPointIndex == null) return;
            const shape = getActiveShape();
            if (!shape) return;
            const r = parseFloat(e.target.value || "0");
            shape.points[selectedPointIndex].radius = Math.max(0, r);
            if (radiusLabel) radiusLabel.textContent = `${r.toFixed(0)} px`;
            renderActiveShape();
        }

        function onGlobalRadiusChange(e) {
            const shape = getActiveShape();
            if (!shape) return;
            const r = parseFloat(e.target.value || "0");
            shape.points.forEach((p) => (p.radius = Math.max(0, r)));
            updateRadiusSliderFromSelected();
            renderActiveShape();
        }

        function resetGlobalRadius() {
            const shape = getActiveShape();
            if (!shape) return;
            if (globalRadiusSlider) globalRadiusSlider.value = INITIAL_RADIUS;
            shape.points.forEach((p) => (p.radius = INITIAL_RADIUS));
            updateRadiusSliderFromSelected();
            renderActiveShape();
        }

        function onDeleteSelectedPoint() {
            const shape = getActiveShape();
            if (selectedPointIndex == null || !shape) return;
            if (shape.points.length <= 3) {
                // Keep at least a triangle
                return;
            }
            shape.points.splice(selectedPointIndex, 1);
            selectedPointIndex = Math.min(selectedPointIndex, shape.points.length - 1);
            if (shape.points.length === 0) selectedPointIndex = null;
            renderActiveShape();
            updateRadiusSliderFromSelected();
        }

        function onSmoothAll() {
            const shape = getActiveShape();
            if (!shape) return;
            shape.points.forEach((p) => {
                p.radius = INITIAL_RADIUS;
            });
            renderActiveShape();
            updateRadiusSliderFromSelected();
        }

        function onSharpAll() {
            const shape = getActiveShape();
            if (!shape) return;
            shape.points.forEach((p) => {
                p.radius = 0;
            });
            renderActiveShape();
            updateRadiusSliderFromSelected();
        }

        // ---------- FRAME STYLE ----------

         // Applies frame style from controls to the *active shape's state and then renders the change.
         
        function applyFrameStyleFromControls() {
            const shape = getActiveShape();
            if (!shape) return;

            shape.frame.strokeStyle = frameStrokeStyleSelect ? frameStrokeStyleSelect.value : "solid";
            shape.frame.stroke = frameStrokeColorInput ? frameStrokeColorInput.value : "var(--color-stroke2)";
            shape.frame.strokeWidth = frameStrokeWidthSlider ? frameStrokeWidthSlider.value : "4";

            const framePathEl = document.getElementById("framePath-" + shape.id);
            if (framePathEl) {
                applyFrameStyleToElement(framePathEl, shape.frame);
            }
        }
      
         /** Helper that applies a frame state object to a specific path element. Used for rendering and for export. */
         
        function applyFrameStyleToElement(pathElement, frameState) {
            if (!pathElement) return;

            const {
                strokeStyle,
                stroke,
                strokeWidth
            } = frameState;

            if (strokeStyle === "none" || strokeWidth == 0) {
                pathElement.setAttribute("stroke", "none");
                pathElement.removeAttribute("stroke-dasharray");
                return;
            }

            pathElement.setAttribute("stroke", stroke);
            pathElement.setAttribute("stroke-width", strokeWidth);

            if (strokeStyle === "solid") {
                pathElement.removeAttribute("stroke-dasharray");
            } else if (strokeStyle === "dashed") {
                pathElement.setAttribute("stroke-dasharray", "10 6");
            } else if (strokeStyle === "dotted") {
                pathElement.setAttribute("stroke-dasharray", "2 4");
            }
        }


        // ---------- SHAPE PRESETS (APPLY) ----------

        function applyShapePresetById(id) {
            const shape = getActiveShape();
            if (!shape) return;

            const preset = SHAPE_PRESETS.find(p => p.id === id);
            if (!preset) return;

            shape.points = getScaledPointsFromPreset(preset);
            selectedPointIndex = 0;
            renderActiveShape();
            updateRadiusSliderFromSelected();
        }

        function applyRectPreset() {
            applyShapePresetById("rounded-rect");
        }

        function applyCirclePreset() {
            applyShapePresetById("circle-8pt");
        }

        function applyPillPreset() {
            applyShapePresetById("pill-horizontal");
        }

        function applyNotchPreset() {
            applyShapePresetById("notch-right");
        }
        function applyTrianglePreset() {
            applyShapePresetById("triangle");
        }

        function applyHexagonPreset() {
            applyShapePresetById("hexagon");
        }

        function applyStarPreset() {
            applyShapePresetById("star");
        }

        function applyDiamondPreset() {
            applyShapePresetById("diamond");
        }
    </script>


    <!-- IMAGE HANDLING -->
    <script>
        function showCanvasLoading() {
            if (!canvasLoadingOverlay) return;
            canvasLoadingOverlay.classList.remove("opacity-0");
            canvasLoadingOverlay.classList.remove("pointer-events-none");
        }

        function hideCanvasLoading() {
            if (!canvasLoadingOverlay) return;
            canvasLoadingOverlay.classList.add("opacity-0");
            canvasLoadingOverlay.classList.add("pointer-events-none");
        }

        function onFileChange(e) {
            const file = e.target.files[0];
            if (!file) return;

            const shape = getActiveShape();
            if (!shape) return;

            shape.image.fileName = file.name || "image.png"; // save original name

            const reader = new FileReader();
            reader.onload = (event) => {
                shape.image.dataUrl = event.target.result;
                const imageLayer = document.getElementById("imageLayer-" + shape.id);
                if (imageLayer) {
                    imageLayer.setAttribute("href", shape.image.dataUrl);
                }
                resetViewport(); // Resets active shape's image transform
            };
            reader.readAsDataURL(file);
        }

        /** Updates the transform attributes for a *specific* shape's image layer. */
         
        function updateImageTransform(shape) {
            if (!shape) return;
            const imageLayer = document.getElementById("imageLayer-" + shape.id);
            if (!imageLayer) return;

            const {
                scale,
                offsetX,
                offsetY,
                opacity,
                fit
            } = shape.image;

            const width = viewBoxWidth * scale;
            const height = viewBoxHeight * scale;

            imageLayer.setAttribute("width", width);
            imageLayer.setAttribute("height", height);
            imageLayer.setAttribute("x", offsetX);
            imageLayer.setAttribute("y", offsetY);
            imageLayer.setAttribute("opacity", opacity);

            if (fit === "cover") {
                imageLayer.setAttribute("preserveAspectRatio", "xMidYMid slice");
            } else if (fit === "contain") {
                imageLayer.setAttribute("preserveAspectRatio", "xMidYMid meet");
            } else if (fit === "stretch") {
                imageLayer.setAttribute("preserveAspectRatio", "none");
            }
        }

        function onZoomChange(e) {
            const shape = getActiveShape();
            if (!shape) return;

            const percent = parseFloat(e.target.value || "100");
            shape.image.scale = percent / 100;

            updateZoomLabel();
            updateImageTransform(shape);
        }

        function updateZoomLabel() {
            if (!zoomLabel) return;
            const shape = getActiveShape();
            const scale = shape ? shape.image.scale : 1;
            zoomLabel.textContent = `${(scale * 100).toFixed(0)}%`;
        }

        function applyImageFit() {
            const shape = getActiveShape();
            if (!shape || !imageFitSelect) return;
            shape.image.fit = imageFitSelect.value;
            updateImageTransform(shape);
        }

        function applyImageOpacity() {
            const shape = getActiveShape();
            if (!shape || !imageOpacitySlider) return;
            const val = parseFloat(imageOpacitySlider.value || "100");
            shape.image.opacity = Math.max(0, Math.min(1, val / 100));
            updateImageTransform(shape);
        }

        function resetViewport() {
            const shape = getActiveShape();
            if (!shape) return;

            shape.image.scale = 1;
            shape.image.offsetX = 0;
            shape.image.offsetY = 0;
            if (zoomSlider) zoomSlider.value = 100;
            updateZoomLabel();
            updateImageTransform(shape);
        }

        // ----- BACKGROUND -----
        function applyBackgroundStyle() {
            if (!backgroundRect) return;

            const useChecker = !!bgCheckerToggle?.checked;
            if (useChecker) {
                backgroundRect.setAttribute("fill", "url(#checker)");
            } else {
                const color = bgColorInput?.value || "#FDFDFD"; 
                backgroundRect.setAttribute("fill", color);

            }
        }
    </script>

    <!-- EXPORT -->
    <script>
        function getExportDimensions() {
            let width = viewBoxWidth;
            let height = viewBoxHeight;

            if (exportUseCanvasSizeToggle && !exportUseCanvasSizeToggle.checked) {
                const w = parseFloat(exportWidthInput?.value || "") || viewBoxWidth;
                const h = parseFloat(exportHeightInput?.value || "") || viewBoxHeight;
                width = Math.max(1, w);
                height = Math.max(1, h);
            }

            return {
                width,
                height
            };
        }

        function getCleanSvgForExport(options = {}) {
            const {
                useFilenameForImageHref = false
            } = options;

            const clone = svg.cloneNode(true);

            // Strip ID from main SVG
            clone.removeAttribute("id");

            // ----- REMOVE CHECKER PATTERN FROM EXPORT -----
            const checkerPattern = clone.querySelector("pattern#checker");
            if (checkerPattern && checkerPattern.parentNode) {
                checkerPattern.parentNode.removeChild(checkerPattern);
            }

            // If <defs> exists but ends up empty (only checker was in it), remove it
            const defsEl = clone.querySelector("defs");
            if (defsEl && defsEl.children.length === 0) {
                defsEl.parentNode.removeChild(defsEl);
            }

            // ----- REMOVE EDITOR UI -----
            const handles = clone.querySelector("#handles");
            if (handles && handles.parentNode) {
                handles.parentNode.removeChild(handles);
            }

            // ----- BACKGROUND HANDLING -----
            const bgRect = clone.querySelector("#checkerBackground");
            const transparent = !!exportTransparentBgToggle?.checked;
            const solid = !!exportSolidBgToggle?.checked;

            if (bgRect) {
                if (transparent) {
                    // fully remove background
                    bgRect.parentNode.removeChild(bgRect);
                } else if (solid) {
                    // replace with solid color
                    const color = exportBgColorInput?.value || "#020617";
                    bgRect.setAttribute("fill", color);
                } else {
                    if (bgRect.getAttribute("fill") === "url(#checker)") {
                        bgRect.setAttribute("fill", "none");
                    }
                }
            }


            // ----- UPDATE ALL SHAPES FOR EXPORT -----
            for (const shape of shapes) {
                // ----- IMAGE HREF HANDLING -----
                const image = clone.querySelector("#imageLayer-" + shape.id);
                if (image) {
                    if (useFilenameForImageHref) {
                        // SVG EXPORT
                        image.setAttribute("href", shape.image.fileName || "image.png");
                    } else {
                        // PNG EXPORT
                        image.setAttribute("href", shape.image.dataUrl);
                    }
                }

                // ----- FRAME STYLE HANDLING -----
                const frame = clone.querySelector("#framePath-" + shape.id);
                if (frame) {
                    if (exportIncludeFrameToggle && exportIncludeFrameToggle.checked) {
                        applyFrameStyleToElement(frame, shape.frame);
                    } else {
                        // Exporting without frame
                        frame.setAttribute("stroke", "none");
                    }
                }
            }


            // ----- VIEWBOX -----
            clone.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`);

            return clone;
        }

        function exportAsSvg() {
            // filename-based href in <image>
            const cleanSvg = getCleanSvgForExport({
                useFilenameForImageHref: true
            });
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(cleanSvg);

            const blob = new Blob([svgString], {
                type: "image/svg+xml;charset=utf-8",
            });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            const baseName = exportFileNameInput?.value?.trim() || "bento-shapes";
            a.href = url;
            a.download = `${baseName}.svg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportAsPng() {
            // embedded data URL for rasterization
            const cleanSvg = getCleanSvgForExport({
                useFilenameForImageHref: false
            });
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(cleanSvg);

            const svgBlob = new Blob([svgString], {
                type: "image/svg+xml;charset=utf-8",
            });
            const url = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = function() {
                const {
                    width,
                    height
                } = getExportDimensions();
                const canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext("2d");

                if (exportSolidBgToggle && exportSolidBgToggle.checked) {
                    const color = exportBgColorInput?.value || "#FDFDFD"; 
                    ctx.fillStyle = color;
                    ctx.fillRect(0, 0, width, height);
                }

                ctx.drawImage(img, 0, 0, width, height);

                URL.revokeObjectURL(url);

                const pngUrl = canvas.toDataURL("image/png");
                const a = document.createElement("a");
                const baseName = exportFileNameInput?.value?.trim() || "bento-shapes";
                a.href = pngUrl;
                a.download = `${baseName}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            };
            img.onerror = function() {
                console.error("Error loading SVG blob image for PNG export.");
                alert("Error exporting PNG. Could not load SVG preview.");
                URL.revokeObjectURL(url);
            }
            img.src = url;
        }
    </script>

    <!-- INIT & SVG BUILDING -->
    <script>
        /** Creates the <clipPath>, <g>, <image>, and <path> elements for all shapes on startup.  */
 
        function buildShapeLayers() {
            if (!svgDefs || !shapeLayersGroup) return;

            for (let i = 0; i < MAX_SHAPES; i++) {
                const shape = shapes[i];
                if (!shape) continue;

                // 1.  <clipPath> in <defs>
                const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
                clipPath.setAttribute("id", "shapeClip-" + shape.id);
                clipPath.setAttribute("clipPathUnits", "userSpaceOnUse");

                const clipPathInner = document.createElementNS("http://www.w3.org/2000/svg", "path");
                clipPathInner.setAttribute("id", "clipPath-" + shape.id);
                clipPath.appendChild(clipPathInner);
                svgDefs.appendChild(clipPath);

                // 2.  shape layer group in main SVG
                const layerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                layerGroup.setAttribute("class", "shape-layer");
                layerGroup.setAttribute("data-shape-id", shape.id);

                // 3.  image group
                const imageGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                imageGroup.setAttribute("id", "imageGroup-" + shape.id);
                imageGroup.setAttribute("clip-path", "url(#shapeClip-" + shape.id + ")");

                // 4.  <image>
                const imageEl = document.createElementNS("http://www.w3.org/2000/svg", "image");
                imageEl.setAttribute("id", "imageLayer-" + shape.id);
                imageEl.setAttribute("href", "");
                imageEl.setAttribute("x", "0");
                imageEl.setAttribute("y", "0");
                imageEl.setAttribute("width", viewBoxWidth);
                imageEl.setAttribute("height", viewBoxHeight);
                imageEl.setAttribute("preserveAspectRatio", "xMidYMid slice");
                imageGroup.appendChild(imageEl);

                // 5.  <path> for frame
                const framePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                framePath.setAttribute("id", "framePath-" + shape.id);
                framePath.setAttribute("fill", "none");
                framePath.setAttribute("stroke", "var(--color-stroke2)");
                framePath.setAttribute("stroke-opacity", "0.9");
                framePath.setAttribute("stroke-width", "4");

                // Add to main group
                layerGroup.appendChild(imageGroup);
                layerGroup.appendChild(framePath);
                shapeLayersGroup.appendChild(layerGroup);
            }
        }


        function initBentoEditor() {
            // Initial canvas inputs
            if (canvasWidthInput) canvasWidthInput.value = viewBoxWidth;
            if (canvasHeightInput) canvasHeightInput.value = viewBoxHeight;

            // Create shape state objects
            shapes = [
                createDefaultShape('shape-1'),
                createDefaultShape('shape-2'),
                createDefaultShape('shape-3')
            ];
            activeShapeIndex = 0;

            // Build the SVG DOM structure
            buildShapeLayers();

            // Initial viewBox
            updateViewBox();

            // Initial frame + points (for shape 1)
            resetFrame(shapes[0]);
            // Give shapes 2 and 3 a default frame too
            resetFrame(shapes[1]);
            resetFrame(shapes[2]);

            // Set active shape to 0 (updates UI)
            setActiveShape(0);

            // UI initial values
            if (radiusSlider) radiusSlider.disabled = true; // Will be enabled by selectPoint
            if (globalRadiusSlider) globalRadiusSlider.value = INITIAL_RADIUS;

            // Background
            applyBackgroundStyle();
        }
    </script>

    <!-- UI WIRING & EVENT LISTENERS -->
    <script>
        initBentoEditor();

        // ----- EVENT WIRING -----

        // Canvas tab
        if (shapeSelectBtn1) shapeSelectBtn1.addEventListener("click", () => setActiveShape(0));
        if (shapeSelectBtn2) shapeSelectBtn2.addEventListener("click", () => setActiveShape(1));
        if (shapeSelectBtn3) shapeSelectBtn3.addEventListener("click", () => setActiveShape(2));

        if (canvasWidthInput) {
            canvasWidthInput.addEventListener("change", applyCanvasSizeFromInputs);
        }
        if (canvasHeightInput) {
            canvasHeightInput.addEventListener("change", applyCanvasSizeFromInputs);
        }
        if (canvasLockAspectToggle) {
            canvasLockAspectToggle.addEventListener("change", applyCanvasSizeFromInputs);
        }
        if (canvasPresetSelect) {
            canvasPresetSelect.addEventListener("change", applyCanvasPreset);
        }
        if (bgCheckerToggle) {
            bgCheckerToggle.addEventListener("change", applyBackgroundStyle);
        }
        if (bgColorInput) {
            bgColorInput.addEventListener("input", applyBackgroundStyle);
        }
        if (viewportResetBtn) {
            viewportResetBtn.addEventListener("click", resetViewport); 
        }

        // Shape tab
        if (modeMoveBtn) modeMoveBtn.addEventListener("click", () => setMode("move"));
        if (modeAddBtn) modeAddBtn.addEventListener("click", () => setMode("add"));
        if (modePanBtn) modePanBtn.addEventListener("click", () => setMode("panImage"));

        if (radiusSlider) {
            radiusSlider.addEventListener("input", onRadiusChange);
        }

        if (globalRadiusSlider) {
            globalRadiusSlider.addEventListener("input", onGlobalRadiusChange);
        }
        if (globalRadiusResetBtn) {
            globalRadiusResetBtn.addEventListener("click", resetGlobalRadius);
        }

        if (deletePointBtn) {
            deletePointBtn.addEventListener("click", onDeleteSelectedPoint);
        }
        if (smoothAllBtn) {
            smoothAllBtn.addEventListener("click", onSmoothAll);
        }
        if (sharpAllBtn) {
            sharpAllBtn.addEventListener("click", onSharpAll);
        }

        if (frameStrokeColorInput) {
            frameStrokeColorInput.addEventListener("input", applyFrameStyleFromControls);
        }
        if (frameStrokeWidthSlider) {
            frameStrokeWidthSlider.addEventListener("input", applyFrameStyleFromControls);
        }
        if (frameStrokeStyleSelect) {
            frameStrokeStyleSelect.addEventListener("change", applyFrameStyleFromControls);
        }

        // Shape Presets
        if (presetRectBtn) presetRectBtn.addEventListener("click", applyRectPreset);
        if (presetCircleBtn) presetCircleBtn.addEventListener("click", applyCirclePreset);
        if (presetPillBtn) presetPillBtn.addEventListener("click", applyPillPreset);
        if (presetNotchBtn) presetNotchBtn.addEventListener("click", applyNotchPreset);
        if (presetTriangleBtn) presetTriangleBtn.addEventListener("click", applyTrianglePreset);
        if (presetHexagonBtn) presetHexagonBtn.addEventListener("click", applyHexagonPreset);
        if (presetStarBtn) presetStarBtn.addEventListener("click", applyStarPreset);
        if (presetDiamondBtn) presetDiamondBtn.addEventListener("click", applyDiamondPreset);


        // Image & export tab
        if (fileInput) {
            fileInput.addEventListener("change", onFileChange);
        }

        // ----- LOAD IMAGE FROM URL -----
        const urlBtn = document.getElementById("loadImageFromUrlBtn");
        const urlInput = document.getElementById("imageUrlInput");

        if (urlBtn && urlInput) {
            urlBtn.addEventListener("click", async () => {
                const url = urlInput.value.trim();
                if (!url) return;

                const shape = getActiveShape();
                if (!shape) return;

                showCanvasLoading();

                try {
                    // This fetch can be blocked by CORS
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Network error: ${response.statusText}`);
                    }

                    const blob = await response.blob();

                    const mime = blob.type || "image/png";
                    const extFromMime = mime.split("/")[1] || "png";
                    shape.image.fileName = `image.${extFromMime}`;

                    const reader = new FileReader();
                    reader.onload = () => {
                        const dataUrl = reader.result;

                        // Store for export & rendering
                        shape.image.dataUrl = dataUrl;
                        const imageLayer = document.getElementById("imageLayer-" + shape.id);
                        if (imageLayer) {
                            imageLayer.setAttribute("href", dataUrl);
                        }

                        resetViewport(); // Resets active shape's image
                    };
                    reader.readAsDataURL(blob);
                } catch (err) {
                    console.error("Error loading image from URL:", err);
                    alert("Unable to load image. Check the URL and ensure the remote server allows cross-origin requests (CORS).");
                } finally {
                    hideCanvasLoading();
                }
            });
        }

        if (zoomSlider) {
            zoomSlider.addEventListener("input", onZoomChange);
        }

        if (imageFitSelect) {
            imageFitSelect.addEventListener("change", applyImageFit);
        }

        if (imageOpacitySlider) {
            imageOpacitySlider.addEventListener("input", applyImageOpacity);
        }

        if (imageResetBtn) {
            imageResetBtn.addEventListener("click", resetViewport);
        }

        if (exportSvgBtn) {
            exportSvgBtn.addEventListener("click", exportAsSvg);
        }
        if (exportPngBtn) {
            exportPngBtn.addEventListener("click", exportAsPng);
        }

        // Export size: toggle enables/disables manual inputs
        if (exportUseCanvasSizeToggle) {
            exportUseCanvasSizeToggle.addEventListener("change", () => {
                const useCanvas = exportUseCanvasSizeToggle.checked;
                if (exportWidthInput) exportWidthInput.disabled = useCanvas;
                if (exportHeightInput) exportHeightInput.disabled = useCanvas;
            });
            // init disabled state
            const useCanvas = exportUseCanvasSizeToggle.checked;
            if (exportWidthInput) exportWidthInput.disabled = useCanvas;
            if (exportHeightInput) exportHeightInput.disabled = useCanvas;
        }

        // SVG pointer events
        svg.addEventListener("pointerdown", onSvgPointerDown);
        svg.addEventListener("pointermove", onSvgPointerMove);
        svg.addEventListener("pointerup", onSvgPointerUp);
        svg.addEventListener("pointerleave", onSvgPointerUp);

        // Reset frame button
        if (resetBtn) {
            resetBtn.addEventListener("click", () => resetFrame(getActiveShape()));
        }
    </script>

    <!-- TOOLBAR TABS -->
    <script>
        (function() {
            const tabButtons = document.querySelectorAll("[data-tab-button]");
            const tabPanels = document.querySelectorAll("[data-tab-panel]");
            const indicator = document.getElementById("toolbarTabIndicator");

            function updateIndicator(activeBtn) {
                if (!indicator || !activeBtn) return;

                const rect = activeBtn.getBoundingClientRect();
                const parentRect = activeBtn.parentElement.getBoundingClientRect();
                const left = rect.left - parentRect.left;
                const width = rect.width;

                indicator.style.left = `${left}px`;
                indicator.style.width = `${width}px`;
            }

            function setActiveTab(targetId) {
                let activeBtn = null;

                // show/hide panels
                tabPanels.forEach(panel => {
                    panel.classList.toggle("hidden", panel.id !== targetId);
                });

                // update tab button styles
                tabButtons.forEach(btn => {
                    const isActive = btn.getAttribute("data-tab-target") === targetId;

                    btn.classList.toggle("text-slate-100", isActive);
                    btn.classList.toggle("font-medium", isActive);
                    btn.classList.toggle("text-slate-400", !isActive);

                    if (isActive) activeBtn = btn;
                });

                // move underline
                if (activeBtn) updateIndicator(activeBtn);
            }

            tabButtons.forEach(btn => {
                btn.addEventListener("click", () => {
                    const targetId = btn.getAttribute("data-tab-target");
                    setActiveTab(targetId);
                });
            });

            // Init: Canvas tab visible by default
            window.addEventListener("load", () => setActiveTab("toolbarTabCanvas"));
        })();
    </script>



</body>

</html>
